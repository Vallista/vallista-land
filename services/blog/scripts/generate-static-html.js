// scripts/generate-static-html.js
import fs from 'fs/promises'
import path from 'path'

// --- 설정 ---
const distDir = path.resolve('dist')
const contentsSourceDir = path.resolve('contents') // ✅ frontmatter 읽을 곳
const filesSourceDir = path.resolve('dist/files') // ✅ HTML 읽을 곳

// --- Utilities ---
function escapeHtml(text = '') {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;')
}

async function loadEntryJsPath() {
  const manifestPath = path.join(distDir, '.vite', 'manifest.json')
  try {
    const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'))
    const mainEntry = Object.values(manifest).find((m) => m.isEntry)
    if (!mainEntry) throw new Error('❌ Main entry not found in manifest.json')

    return mainEntry.file // ex) assets/index-abc123.js
  } catch (err) {
    console.error('❌ dist/.vite/manifest.json이 없습니다. 먼저 vite build를 실행하세요.')
    throw err
  }
}

function createSeoHead(meta) {
  const { name, description, image, isPost = false, siteUrl = 'https://vallista.kr', pathname = '' } = meta
  const url = siteUrl + pathname
  const ogType = isPost ? 'article' : 'website'

  const formattedTitle = escapeHtml(name)

  return `
  <meta charset="UTF-8">
  <title>${formattedTitle}</title>
  
  ${description ? `<meta name="description" content="${escapeHtml(description)}">` : ''}
  <meta name="image" content="${escapeHtml(image)}">

  <meta property="og:url" content="${escapeHtml(url)}">
  <meta property="og:type" content="${ogType}">
  <meta property="og:title" content="${escapeHtml(name)}">
  ${description ? `<meta property="og:description" content="${escapeHtml(description)}">` : ''}
  <meta property="og:image" content="${escapeHtml(image)}">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="${escapeHtml(name)}">
  ${description ? `<meta name="twitter:description" content="${escapeHtml(description)}">` : ''}
  <meta name="twitter:image" content="${escapeHtml(image)}">

  <meta name="google-site-verification" content="wPI09aIL9InuxJwKlMkLE-4mzzfbNhQqRCJ760C-8nQ">
  `.trim()
}

function parseFrontmatter(text) {
  const match = text.match(/^<!--\s*frontmatter\s*({[\s\S]*?})\s*-->/)
  if (match) {
    try {
      return JSON.parse(match[1])
    } catch (e) {
      console.error('❌ Failed to parse frontmatter JSON:', e)
    }
  }
  return null
}

// --- Main ---
async function generateStaticHtml() {
  const layoutPath = path.join(distDir, 'layout.html')
  const layoutTemplateRaw = await fs.readFile(layoutPath, 'utf-8')
  const entryJsPath = await loadEntryJsPath()
  const layoutTemplate = layoutTemplateRaw.replace('{{entry}}', entryJsPath)

  const entries = await walkEntries(contentsSourceDir)

  for (const entry of entries) {
    const { slug, contentPath } = entry

    // 1. frontmatter 읽기
    const contentRaw = await fs.readFile(contentPath, 'utf-8')
    const meta = parseFrontmatter(contentRaw) || {}

    // 2. 본문 HTML 읽기
    const htmlPath1 = path.join(filesSourceDir, 'contents', slug + '.html')
    const htmlPath2 = path.join(filesSourceDir, 'contents', slug, 'index.html')

    let mainContent = ''
    try {
      try {
        mainContent = await fs.readFile(htmlPath1, 'utf-8')
      } catch {
        mainContent = await fs.readFile(htmlPath2, 'utf-8')
      }
    } catch (err) {
      console.error(`❌ 본문 HTML 파일 없음: ${htmlPath1} 또는 ${htmlPath2}`)
      process.exit(1)
    }

    const autoGeneratedDescription = generateDescriptionFromContent(contentRaw)

    // --- 타이틀
    let titleBase = meta.name
    if (!titleBase) {
      // 이름도 없으면 slug 마지막 부분 사용
      titleBase = slug.split('/').pop() || 'vallista.dev'
    }
    const title = `${titleBase}`

    // --- 디스크립션
    let description = meta.description || autoGeneratedDescription
    if (!description || description.trim().length === 0) {
      description = null // 아예 description 메타태그 생략 가능
    }

    const isPost = meta.isPost || false
    const pathname = meta.pathname || `/contents/${slug}`
    const siteUrl = meta.siteUrl || 'https://vallista.kr'

    // og:image 설정
    const imagePath = meta.image ? `${siteUrl}/contents/${slug}/assets/og.png` : `${siteUrl}/profile.png`

    const headHtml = createSeoHead({
      name: title,
      description,
      image: imagePath,
      isPost,
      siteUrl,
      pathname
    })

    const finalHtml = layoutTemplate.replace('<!-- {{head}} -->', headHtml).replace('<!-- {{content}} -->', mainContent)

    const targetDir = path.join(distDir, 'contents', slug)
    await fs.mkdir(targetDir, { recursive: true })
    await fs.writeFile(path.join(targetDir, 'index.html'), finalHtml)

    console.log(`✅ Generated: contents/${slug}/index.html`)
  }

  console.log('🎉 All static HTML files generated!')
}

// --- Helpers ---
async function walkEntries(dir) {
  let results = []
  const list = await fs.readdir(dir, { withFileTypes: true })

  for (const file of list) {
    const filePath = path.join(dir, file.name)

    if (file.isDirectory()) {
      const deeper = await walkEntries(filePath)
      results = results.concat(deeper)
    } else if (/\.(html|md|mdx)$/.test(file.name)) {
      const relativePath = path.relative(contentsSourceDir, filePath).replace(/\\/g, '/')

      let slug = relativePath.replace(/\.(html|md|mdx)$/, '') // 확장자 제거

      if (slug.endsWith('/index')) {
        slug = slug.slice(0, slug.length - '/index'.length)
      }

      results.push({
        slug,
        contentPath: filePath
      })
    }
  }

  return results
}

function generateDescriptionFromContent(rawContent) {
  let content = rawContent

  // 1. frontmatter 블록 제거
  content = content.replace(/^---[\s\S]*?---/, '').trim()

  // 2. 맨 처음 나오는 이미지 제거
  content = content.replace(/^!\[[^\]]*\]\([^)]*\)\s*/, '').trim()

  // 3. 링크 제거
  content = content.replace(/\[[^\]]*\]\([^)]*\)/g, '').trim()

  // 4. HTML 태그 제거
  content = content.replace(/<[^>]+>/g, '').trim()

  // 5. 연속 공백 하나로 압축
  content = content.replace(/\s+/g, ' ').trim()

  // 6. 150자 이내로 자르기
  return content.slice(0, 150)
}

generateStaticHtml()
