import fs from 'fs/promises'
import path from 'path'

const distDir = path.resolve('dist')
const contentsSourceDir = path.resolve('contents')
const filesSourceDir = path.resolve('dist/files')

function escapeHtml(text = '') {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;')
}

async function loadEntryJsPath() {
  const manifestPath = path.join(distDir, '.vite', 'manifest.json')
  try {
    const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'))
    const mainEntry = Object.values(manifest).find((m) => m.isEntry)
    if (!mainEntry) throw new Error('❌ Main entry not found in manifest.json')

    return mainEntry.file
  } catch (err) {
    console.error('❌ dist/.vite/manifest.json이 없습니다. 먼저 vite build를 실행하세요.')
    throw err
  }
}

function createSeoHead(meta) {
  const { name, description, image, isPost = false, siteUrl = 'https://vallista.kr', pathname = '' } = meta
  const url = siteUrl + pathname
  const ogType = isPost ? 'article' : 'website'

  const formattedTitle = escapeHtml(name)

  return `
  <meta charset="UTF-8">
  <title>${formattedTitle}</title>
  ${description ? `<meta name="description" content="${escapeHtml(description)}">` : ''}
  <meta name="image" content="${escapeHtml(image)}">
  <meta property="og:url" content="${escapeHtml(url)}">
  <meta property="og:type" content="${ogType}">
  <meta property="og:title" content="${escapeHtml(name)}">
  ${description ? `<meta property="og:description" content="${escapeHtml(description)}">` : ''}
  <meta property="og:image" content="${escapeHtml(image)}">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="${escapeHtml(name)}">
  ${description ? `<meta name="twitter:description" content="${escapeHtml(description)}">` : ''}
  <meta name="twitter:image" content="${escapeHtml(image)}">
  <meta name="google-site-verification" content="wPI09aIL9InuxJwKlMkLE-4mzzfbNhQqRCJ760C-8nQ">
  `.trim()
}

function parseFrontmatter(text) {
  const match = text.match(/^---\s*[\r\n]+([\s\S]*?)\r?\n---/)
  if (!match) return null

  const lines = match[1].split(/\r?\n/)

  const result = {}

  for (const line of lines) {
    const trimmed = line.trim()
    if (!trimmed || !trimmed.includes(':')) continue

    const [keyPart, ...valueParts] = trimmed.split(':')
    const key = keyPart.trim()
    const rawValue = valueParts.join(':').trim()

    // 간단한 타입 변환
    let value = rawValue
    if (value === 'null') value = null
    else if (value === 'true') value = true
    else if (value === 'false') value = false
    else if (!isNaN(Date.parse(value)))
      value = value // date string
    else if (!isNaN(Number(value))) value = Number(value)

    result[key] = value
  }

  return result
}

async function generateStaticHtml() {
  const layoutPath = path.join(distDir, 'layout.html')
  const layoutTemplateRaw = await fs.readFile(layoutPath, 'utf-8')
  const entryJsPath = await loadEntryJsPath()
  const layoutTemplate = layoutTemplateRaw.replace('{{entry}}', entryJsPath)

  const entries = await walkEntries(contentsSourceDir)

  for (const entry of entries) {
    const { slug, trail, contentPath } = entry

    const contentRaw = await fs.readFile(contentPath, 'utf-8')
    const meta = parseFrontmatter(contentRaw) || {}
    const autoGeneratedDescription = generateDescriptionFromContent(contentRaw)

    // ✅ slug를 frontmatter의 slug로 치환 (없으면 기존 slug 사용)
    const actualSlug = meta.slug || slug
    const slugPathSegments = ['contents', ...trail, actualSlug]

    // ✅ HTML 경로 재구성
    const htmlPath = path.join(filesSourceDir, ...slugPathSegments, 'index.html')

    let mainContent = ''
    try {
      mainContent = await fs.readFile(htmlPath, 'utf-8')
    } catch (err) {
      console.error(`❌ 본문 HTML 파일 없음: ${htmlPath}`)
      continue
    }

    const title = meta.name || slugPathSegments.at(-1) || 'vallista.dev'
    const description = meta.description || autoGeneratedDescription || null
    const isPost = meta.isPost || false
    const pathname = meta.pathname || `/contents/${slug}`
    const siteUrl = meta.siteUrl || 'https://vallista.kr'
    const imagePath = meta.image ? `${siteUrl}/contents/${slug}/assets/og.png` : `${siteUrl}/profile.png`

    const headHtml = createSeoHead({
      name: title,
      description,
      image: imagePath,
      isPost,
      siteUrl,
      pathname
    })

    const finalHtml = layoutTemplate.replace('<!-- {{head}} -->', headHtml).replace('<!-- {{content}} -->', mainContent)

    const targetDir = path.join(distDir, 'contents', ...slugPathSegments)
    await fs.mkdir(targetDir, { recursive: true })
    await fs.writeFile(path.join(targetDir, 'index.html'), finalHtml)

    console.log(`✅ Generated: contents/${slug}/index.html`)
  }

  console.log('🎉 All static HTML files generated!')
}

async function walkEntries(dir) {
  let results = []
  const list = await fs.readdir(dir, { withFileTypes: true })

  for (const file of list) {
    const filePath = path.join(dir, file.name)

    if (file.isDirectory()) {
      const deeper = await walkEntries(filePath)
      results = results.concat(deeper)
    } else if (/\.(md|mdx)$/.test(file.name)) {
      const relativePath = path.relative(contentsSourceDir, filePath).replace(/\\/g, '/')
      let cleanPath = relativePath.replace(/\.(md|mdx)$/, '')

      // slug 추출 (마지막 이름만)
      let slug = cleanPath
      if (slug.endsWith('/index')) {
        slug = path.basename(path.dirname(cleanPath)) // 폴더 이름
      } else {
        slug = path.basename(cleanPath) // 파일 이름
      }

      // trail은 확장자 제거한 경로에서 slug 제외
      let trail = cleanPath.split('/').slice(0, -1)
      trail = trail.filter((segment) => segment !== slug)

      results.push({
        slug, // ex: 'foo-post'
        trail, // ex: ['contents', 'articles']
        slugPathSegments: [...trail, slug], // ex: ['contents', 'articles', 'foo-post']
        contentPath: filePath
      })
    }
  }

  return results
}

function generateDescriptionFromContent(rawContent) {
  let content = rawContent
  content = content.replace(/^---[\s\S]*?---/, '').trim()
  content = content.replace(/^!\[[^\]]*\]\([^)]*\)\s*/, '').trim()
  content = content.replace(/\[[^\]]*\]\([^)]*\)/g, '').trim()
  content = content.replace(/<[^>]+>/g, '').trim()
  content = content.replace(/\s+/g, ' ').trim()
  return content.slice(0, 150)
}

generateStaticHtml()
