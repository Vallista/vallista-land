// scripts/generate-static-html.js
import fs from 'fs/promises'
import path from 'path'

// --- ì„¤ì • ---
const distDir = path.resolve('dist')
const contentsSourceDir = path.resolve('contents') // âœ… frontmatter ì½ì„ ê³³
const filesSourceDir = path.resolve('dist/files') // âœ… HTML ì½ì„ ê³³

// --- Utilities ---
function escapeHtml(text = '') {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;')
}

async function loadEntryJsPath() {
  const manifestPath = path.join(distDir, '.vite', 'manifest.json')
  try {
    const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'))
    const mainEntry = Object.values(manifest).find((m) => m.isEntry)
    if (!mainEntry) throw new Error('âŒ Main entry not found in manifest.json')

    return mainEntry.file // ex) assets/index-abc123.js
  } catch (err) {
    console.error('âŒ dist/.vite/manifest.jsonì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € vite buildë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.')
    throw err
  }
}

function createSeoHead(meta) {
  const { name, description, image, isPost = false, siteUrl = 'https://vallista.kr', pathname = '' } = meta
  const url = siteUrl + pathname
  const ogType = isPost ? 'article' : 'website'

  const formattedTitle = escapeHtml(name)

  return `
  <meta charset="UTF-8">
  <title>${formattedTitle}</title>
  
  ${description ? `<meta name="description" content="${escapeHtml(description)}">` : ''}
  <meta name="image" content="${escapeHtml(image)}">

  <meta property="og:url" content="${escapeHtml(url)}">
  <meta property="og:type" content="${ogType}">
  <meta property="og:title" content="${escapeHtml(name)}">
  ${description ? `<meta property="og:description" content="${escapeHtml(description)}">` : ''}
  <meta property="og:image" content="${escapeHtml(image)}">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="${escapeHtml(name)}">
  ${description ? `<meta name="twitter:description" content="${escapeHtml(description)}">` : ''}
  <meta name="twitter:image" content="${escapeHtml(image)}">

  <meta name="google-site-verification" content="wPI09aIL9InuxJwKlMkLE-4mzzfbNhQqRCJ760C-8nQ">
  `.trim()
}

function parseFrontmatter(text) {
  const match = text.match(/^<!--\s*frontmatter\s*({[\s\S]*?})\s*-->/)
  if (match) {
    try {
      return JSON.parse(match[1])
    } catch (e) {
      console.error('âŒ Failed to parse frontmatter JSON:', e)
    }
  }
  return null
}

// --- Main ---
async function generateStaticHtml() {
  const layoutPath = path.join(distDir, 'layout.html')
  const layoutTemplateRaw = await fs.readFile(layoutPath, 'utf-8')
  const entryJsPath = await loadEntryJsPath()
  const layoutTemplate = layoutTemplateRaw.replace('{{entry}}', entryJsPath)

  const entries = await walkEntries(contentsSourceDir)

  for (const entry of entries) {
    const { slug, contentPath } = entry

    // 1. frontmatter ì½ê¸°
    const contentRaw = await fs.readFile(contentPath, 'utf-8')
    const meta = parseFrontmatter(contentRaw) || {}

    // 2. ë³¸ë¬¸ HTML ì½ê¸°
    const htmlPath1 = path.join(filesSourceDir, 'contents', slug + '.html')
    const htmlPath2 = path.join(filesSourceDir, 'contents', slug, 'index.html')

    let mainContent = ''
    try {
      try {
        mainContent = await fs.readFile(htmlPath1, 'utf-8')
      } catch {
        mainContent = await fs.readFile(htmlPath2, 'utf-8')
      }
    } catch (err) {
      console.error(`âŒ ë³¸ë¬¸ HTML íŒŒì¼ ì—†ìŒ: ${htmlPath1} ë˜ëŠ” ${htmlPath2}`)
      process.exit(1)
    }

    const autoGeneratedDescription = generateDescriptionFromContent(contentRaw)

    // --- íƒ€ì´í‹€
    let titleBase = meta.name
    if (!titleBase) {
      // ì´ë¦„ë„ ì—†ìœ¼ë©´ slug ë§ˆì§€ë§‰ ë¶€ë¶„ ì‚¬ìš©
      titleBase = slug.split('/').pop() || 'vallista.dev'
    }
    const title = `${titleBase}`

    // --- ë””ìŠ¤í¬ë¦½ì…˜
    let description = meta.description || autoGeneratedDescription
    if (!description || description.trim().length === 0) {
      description = null // ì•„ì˜ˆ description ë©”íƒ€íƒœê·¸ ìƒëµ ê°€ëŠ¥
    }

    const isPost = meta.isPost || false
    const pathname = meta.pathname || `/contents/${slug}`
    const siteUrl = meta.siteUrl || 'https://vallista.kr'

    // og:image ì„¤ì •
    const imagePath = meta.image ? `${siteUrl}/contents/${slug}/assets/og.png` : `${siteUrl}/profile.png`

    const headHtml = createSeoHead({
      name: title,
      description,
      image: imagePath,
      isPost,
      siteUrl,
      pathname
    })

    const finalHtml = layoutTemplate.replace('<!-- {{head}} -->', headHtml).replace('<!-- {{content}} -->', mainContent)

    const targetDir = path.join(distDir, 'contents', slug)
    await fs.mkdir(targetDir, { recursive: true })
    await fs.writeFile(path.join(targetDir, 'index.html'), finalHtml)

    console.log(`âœ… Generated: contents/${slug}/index.html`)
  }

  console.log('ğŸ‰ All static HTML files generated!')
}

// --- Helpers ---
async function walkEntries(dir) {
  let results = []
  const list = await fs.readdir(dir, { withFileTypes: true })

  for (const file of list) {
    const filePath = path.join(dir, file.name)

    if (file.isDirectory()) {
      const deeper = await walkEntries(filePath)
      results = results.concat(deeper)
    } else if (/\.(html|md|mdx)$/.test(file.name)) {
      const relativePath = path.relative(contentsSourceDir, filePath).replace(/\\/g, '/')

      let slug = relativePath.replace(/\.(html|md|mdx)$/, '') // í™•ì¥ì ì œê±°

      if (slug.endsWith('/index')) {
        slug = slug.slice(0, slug.length - '/index'.length)
      }

      results.push({
        slug,
        contentPath: filePath
      })
    }
  }

  return results
}

function generateDescriptionFromContent(rawContent) {
  let content = rawContent

  // 1. frontmatter ë¸”ë¡ ì œê±°
  content = content.replace(/^---[\s\S]*?---/, '').trim()

  // 2. ë§¨ ì²˜ìŒ ë‚˜ì˜¤ëŠ” ì´ë¯¸ì§€ ì œê±°
  content = content.replace(/^!\[[^\]]*\]\([^)]*\)\s*/, '').trim()

  // 3. ë§í¬ ì œê±°
  content = content.replace(/\[[^\]]*\]\([^)]*\)/g, '').trim()

  // 4. HTML íƒœê·¸ ì œê±°
  content = content.replace(/<[^>]+>/g, '').trim()

  // 5. ì—°ì† ê³µë°± í•˜ë‚˜ë¡œ ì••ì¶•
  content = content.replace(/\s+/g, ' ').trim()

  // 6. 150ì ì´ë‚´ë¡œ ìë¥´ê¸°
  return content.slice(0, 150)
}

generateStaticHtml()
